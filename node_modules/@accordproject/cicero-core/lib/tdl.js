// Generated automatically by nearley, version 2.16.0
// http://github.com/Hardmath123/nearley
(function () {
function id(x) { return x[0]; }

  const flatten = d => {
    return d.reduce(
      (a, b) => {
          if(b) {
            return a.concat(b);
          } else {
              return a;
          }
      },
      []
    );
  };

const moo = require("moo");

const escapeNearley = (x) => {
    return x.replace(/\t/g, '\\t') // Replace tab due to Nearley bug #nearley/issues/413
        .replace(/\f/g, '\\f')
        .replace(/\r/g, '\\r');
}

// we use lexer states to distinguish between the tokens
// in the text and the tokens inside the variables
const lexer = moo.states({
    main: {
        // a chunk is everything up until '{[', even across newlines. We then trim off the '{['
        // we also push the lexer into the 'var' state
        Chunk: {
            match: /[^]*?{{/,
            lineBreaks: true,
            push: 'markup',
            value: x => escapeNearley(x.slice(0, -2))
        },
        // we now need to consume everything up until the end of the buffer.
        // note that the order of these two rules is important!
        LastChunk : {
            match: /[^]+/,
            lineBreaks: true,
            value: x => escapeNearley(x)
        }
    },
    markup: { // This is a dispatch to the correct lexical state (using moo's "next")
        markupstartblock: {
            match: '#',
            next: 'startblock',
        },
        markupstartref: {
            match: '>',
            next: 'startref',
        },
        markupendblock: {
            match: '/',
            next: 'endblock',
        },
        markupexpr: {
            match: '%',
            next: 'expr',
        },
        varend: {
            match: '}}',
            pop: true
        }, // pop back to main state
        varelseid: 'else',
        varid: {
          match: /[a-zA-Z_][_a-zA-Z0-9]*/,
          type: moo.keywords({varas: 'as'})
        },
        varstring: /".*?"/,
        varspace: ' ',
    },
    expr: {
        exprend: {
            match: /[^]*?[%]}}/,
            lineBreaks: true,
            pop: true
        },
    },
    startblock: {
        startblockend: {
            match: '}}',
            pop: true,
        }, // pop back to main state
        startblockspace: / +/,
        startclauseid: 'clause',
        startwithid: 'with',
        startulistid: 'ulist',
        startolistid: 'olist',
        startjoinid: 'join',
        startifid: 'if',
        startblockstring: /".*?"/,
        startblockid: /[a-zA-Z_][_a-zA-Z0-9]*/,
    },
    startref: {
        startrefend: {
            match: '}}',
            pop: true,
        }, // pop back to main state
        startrefspace: / +/,
        startrefid: /[a-zA-Z_][_a-zA-Z0-9]*/,
    },
    endblock: {
        endblockend: {
            match: '}}',
            pop: true
        }, // pop back to main state
        endclauseid: 'clause',
        endwithid: 'with',
        endulistid: 'ulist',
        endolistid: 'olist',
        endjoinid: 'join',
        endifid: 'if',
    },
});
var grammar = {
    Lexer: lexer,
    ParserRules: [
    {"name": "_$ebnf$1", "symbols": []},
    {"name": "_$ebnf$1", "symbols": ["_$ebnf$1", "wschar"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "_", "symbols": ["_$ebnf$1"], "postprocess": function(d) {return null;}},
    {"name": "__$ebnf$1", "symbols": ["wschar"]},
    {"name": "__$ebnf$1", "symbols": ["__$ebnf$1", "wschar"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "__", "symbols": ["__$ebnf$1"], "postprocess": function(d) {return null;}},
    {"name": "wschar", "symbols": [/[ \t\n\v\f]/], "postprocess": id},
    {"name": "dqstring$ebnf$1", "symbols": []},
    {"name": "dqstring$ebnf$1", "symbols": ["dqstring$ebnf$1", "dstrchar"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "dqstring", "symbols": [{"literal":"\""}, "dqstring$ebnf$1", {"literal":"\""}], "postprocess": function(d) {return d[1].join(""); }},
    {"name": "sqstring$ebnf$1", "symbols": []},
    {"name": "sqstring$ebnf$1", "symbols": ["sqstring$ebnf$1", "sstrchar"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "sqstring", "symbols": [{"literal":"'"}, "sqstring$ebnf$1", {"literal":"'"}], "postprocess": function(d) {return d[1].join(""); }},
    {"name": "btstring$ebnf$1", "symbols": []},
    {"name": "btstring$ebnf$1", "symbols": ["btstring$ebnf$1", /[^`]/], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "btstring", "symbols": [{"literal":"`"}, "btstring$ebnf$1", {"literal":"`"}], "postprocess": function(d) {return d[1].join(""); }},
    {"name": "dstrchar", "symbols": [/[^\\"\n]/], "postprocess": id},
    {"name": "dstrchar", "symbols": [{"literal":"\\"}, "strescape"], "postprocess": 
        function(d) {
            return JSON.parse("\""+d.join("")+"\"");
        }
        },
    {"name": "sstrchar", "symbols": [/[^\\'\n]/], "postprocess": id},
    {"name": "sstrchar", "symbols": [{"literal":"\\"}, "strescape"], "postprocess": function(d) { return JSON.parse("\""+d.join("")+"\""); }},
    {"name": "sstrchar$string$1", "symbols": [{"literal":"\\"}, {"literal":"'"}], "postprocess": function joiner(d) {return d.join('');}},
    {"name": "sstrchar", "symbols": ["sstrchar$string$1"], "postprocess": function(d) {return "'"; }},
    {"name": "strescape", "symbols": [/["\\\/bfnrt]/], "postprocess": id},
    {"name": "strescape", "symbols": [{"literal":"u"}, /[a-fA-F0-9]/, /[a-fA-F0-9]/, /[a-fA-F0-9]/, /[a-fA-F0-9]/], "postprocess": 
        function(d) {
            return d.join("");
        }
        },
    {"name": "TEMPLATE", "symbols": ["CONTRACT_TEMPLATE"], "postprocess": id},
    {"name": "CONTRACT_TEMPLATE$ebnf$1", "symbols": []},
    {"name": "CONTRACT_TEMPLATE$ebnf$1", "symbols": ["CONTRACT_TEMPLATE$ebnf$1", "CONTRACT_ITEM"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "CONTRACT_TEMPLATE$ebnf$2", "symbols": [(lexer.has("LastChunk") ? {type: "LastChunk"} : LastChunk)], "postprocess": id},
    {"name": "CONTRACT_TEMPLATE$ebnf$2", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "CONTRACT_TEMPLATE", "symbols": ["CONTRACT_TEMPLATE$ebnf$1", "CONTRACT_TEMPLATE$ebnf$2"], "postprocess":  (data) => {
            return {
                type: 'ContractTemplate',
                data: flatten(data)
            };
        }
        },
    {"name": "CONTRACT_ITEM", "symbols": [(lexer.has("Chunk") ? {type: "Chunk"} : Chunk)], "postprocess": id},
    {"name": "CONTRACT_ITEM", "symbols": [(lexer.has("markupstartblock") ? {type: "markupstartblock"} : markupstartblock), "ULIST_BLOCK_INLINE"], "postprocess": (data) => { return data[1]; }},
    {"name": "CONTRACT_ITEM", "symbols": [(lexer.has("markupstartblock") ? {type: "markupstartblock"} : markupstartblock), "OLIST_BLOCK_INLINE"], "postprocess": (data) => { return data[1]; }},
    {"name": "CONTRACT_ITEM", "symbols": [(lexer.has("markupstartblock") ? {type: "markupstartblock"} : markupstartblock), "JOIN_BLOCK_INLINE"], "postprocess": (data) => { return data[1]; }},
    {"name": "CONTRACT_ITEM", "symbols": [(lexer.has("markupstartblock") ? {type: "markupstartblock"} : markupstartblock), "IF_BLOCK_INLINE"], "postprocess": (data) => { return data[1]; }},
    {"name": "CONTRACT_ITEM", "symbols": [(lexer.has("markupstartblock") ? {type: "markupstartblock"} : markupstartblock), "CLAUSE_BLOCK_INLINE"], "postprocess": (data) => { return data[1]; }},
    {"name": "CONTRACT_ITEM", "symbols": [(lexer.has("markupstartblock") ? {type: "markupstartblock"} : markupstartblock), "WITH_BLOCK_INLINE"], "postprocess": (data) => { return data[1]; }},
    {"name": "CONTRACT_ITEM", "symbols": [(lexer.has("markupstartref") ? {type: "markupstartref"} : markupstartref), "CLAUSE_BLOCK_EXTERNAL"], "postprocess": (data) => { return data[1]; }},
    {"name": "CONTRACT_ITEM", "symbols": [(lexer.has("markupexpr") ? {type: "markupexpr"} : markupexpr), "CLAUSE_EXPR"], "postprocess": (data) => { return data[1]; }},
    {"name": "CONTRACT_ITEM", "symbols": ["VARIABLE"], "postprocess": id},
    {"name": "CLAUSE_TEMPLATE$ebnf$1", "symbols": []},
    {"name": "CLAUSE_TEMPLATE$ebnf$1", "symbols": ["CLAUSE_TEMPLATE$ebnf$1", "CLAUSE_ITEM"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "CLAUSE_TEMPLATE$ebnf$2", "symbols": [(lexer.has("LastChunk") ? {type: "LastChunk"} : LastChunk)], "postprocess": id},
    {"name": "CLAUSE_TEMPLATE$ebnf$2", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "CLAUSE_TEMPLATE", "symbols": ["CLAUSE_TEMPLATE$ebnf$1", "CLAUSE_TEMPLATE$ebnf$2"], "postprocess":  (data) => {
            return {
                type: 'ClauseTemplate',
                data: flatten(data)
            };
        }
        },
    {"name": "CLAUSE_ITEM", "symbols": [(lexer.has("Chunk") ? {type: "Chunk"} : Chunk)], "postprocess": id},
    {"name": "CLAUSE_ITEM", "symbols": [(lexer.has("markupstartblock") ? {type: "markupstartblock"} : markupstartblock), "ULIST_BLOCK_INLINE"], "postprocess": (data) => { return data[1]; }},
    {"name": "CLAUSE_ITEM", "symbols": [(lexer.has("markupstartblock") ? {type: "markupstartblock"} : markupstartblock), "OLIST_BLOCK_INLINE"], "postprocess": (data) => { return data[1]; }},
    {"name": "CLAUSE_ITEM", "symbols": [(lexer.has("markupstartblock") ? {type: "markupstartblock"} : markupstartblock), "JOIN_BLOCK_INLINE"], "postprocess": (data) => { return data[1]; }},
    {"name": "CLAUSE_ITEM", "symbols": [(lexer.has("markupstartblock") ? {type: "markupstartblock"} : markupstartblock), "IF_BLOCK_INLINE"], "postprocess": (data) => { return data[1]; }},
    {"name": "CLAUSE_ITEM", "symbols": [(lexer.has("markupstartblock") ? {type: "markupstartblock"} : markupstartblock), "WITH_BLOCK_INLINE"], "postprocess": (data) => { return data[1]; }},
    {"name": "CLAUSE_ITEM", "symbols": [(lexer.has("markupexpr") ? {type: "markupexpr"} : markupexpr), "CLAUSE_EXPR"], "postprocess": (data) => { return data[1]; }},
    {"name": "CLAUSE_ITEM", "symbols": ["VARIABLE"], "postprocess": id},
    {"name": "CLAUSE_EXPR", "symbols": [(lexer.has("exprend") ? {type: "exprend"} : exprend)], "postprocess":  (data) => {
            return {
                type: 'Expr'
            }
        }
        },
    {"name": "CLAUSE_BLOCK_INLINE", "symbols": [(lexer.has("startclauseid") ? {type: "startclauseid"} : startclauseid), (lexer.has("startblockspace") ? {type: "startblockspace"} : startblockspace), (lexer.has("startblockid") ? {type: "startblockid"} : startblockid), (lexer.has("startblockend") ? {type: "startblockend"} : startblockend), "CLAUSE_TEMPLATE", (lexer.has("markupendblock") ? {type: "markupendblock"} : markupendblock), (lexer.has("endclauseid") ? {type: "endclauseid"} : endclauseid), (lexer.has("endblockend") ? {type: "endblockend"} : endblockend)], "postprocess":  (data,l,reject) => {
            // Check that opening and closing clause tags match
            // Note: this line makes the parser non-context-free
            return {
                type: 'ClauseBinding',
                template: data[4],
                fieldName: data[2]
            }
        }
        },
    {"name": "WITH_BLOCK_INLINE", "symbols": [(lexer.has("startwithid") ? {type: "startwithid"} : startwithid), (lexer.has("startblockspace") ? {type: "startblockspace"} : startblockspace), (lexer.has("startblockid") ? {type: "startblockid"} : startblockid), (lexer.has("startblockend") ? {type: "startblockend"} : startblockend), "CLAUSE_TEMPLATE", (lexer.has("markupendblock") ? {type: "markupendblock"} : markupendblock), (lexer.has("endwithid") ? {type: "endwithid"} : endwithid), (lexer.has("endblockend") ? {type: "endblockend"} : endblockend)], "postprocess":  (data,l,reject) => {
            // Check that opening and closing clause tags match
            // Note: this line makes the parser non-context-free
            return {
                type: 'WithBinding',
                template: data[4],
                fieldName: data[2]
            }
        }
        },
    {"name": "CLAUSE_BLOCK_EXTERNAL$ebnf$1", "symbols": [(lexer.has("startrefspace") ? {type: "startrefspace"} : startrefspace)], "postprocess": id},
    {"name": "CLAUSE_BLOCK_EXTERNAL$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "CLAUSE_BLOCK_EXTERNAL", "symbols": ["CLAUSE_BLOCK_EXTERNAL$ebnf$1", (lexer.has("startrefid") ? {type: "startrefid"} : startrefid), (lexer.has("startrefend") ? {type: "startrefend"} : startrefend)], "postprocess":  (data) => {
            return {
                type: 'ClauseExternalBinding',
                fieldName: data[1]
            }
        } 
        },
    {"name": "ULIST_BLOCK_INLINE", "symbols": [(lexer.has("startulistid") ? {type: "startulistid"} : startulistid), (lexer.has("startblockspace") ? {type: "startblockspace"} : startblockspace), (lexer.has("startblockid") ? {type: "startblockid"} : startblockid), (lexer.has("startblockend") ? {type: "startblockend"} : startblockend), "CLAUSE_TEMPLATE", (lexer.has("markupendblock") ? {type: "markupendblock"} : markupendblock), (lexer.has("endulistid") ? {type: "endulistid"} : endulistid), (lexer.has("endblockend") ? {type: "endblockend"} : endblockend)], "postprocess":  (data,l,reject) => {
            // Check that opening and closing clause tags match
            // Note: this line makes the parser non-context-free
                return {
                    type: 'UListBinding',
                    template: data[4],
                    fieldName: data[2]
                }
        }
        },
    {"name": "OLIST_BLOCK_INLINE", "symbols": [(lexer.has("startolistid") ? {type: "startolistid"} : startolistid), (lexer.has("startblockspace") ? {type: "startblockspace"} : startblockspace), (lexer.has("startblockid") ? {type: "startblockid"} : startblockid), (lexer.has("startblockend") ? {type: "startblockend"} : startblockend), "CLAUSE_TEMPLATE", (lexer.has("markupendblock") ? {type: "markupendblock"} : markupendblock), (lexer.has("endolistid") ? {type: "endolistid"} : endolistid), (lexer.has("endblockend") ? {type: "endblockend"} : endblockend)], "postprocess":  (data,l,reject) => {
            // Check that opening and closing clause tags match
            // Note: this line makes the parser non-context-free
                return {
                    type: 'OListBinding',
                    template: data[4],
                    fieldName: data[2]
                }
        }
        },
    {"name": "JOIN_BLOCK_INLINE", "symbols": [(lexer.has("startjoinid") ? {type: "startjoinid"} : startjoinid), (lexer.has("startblockspace") ? {type: "startblockspace"} : startblockspace), (lexer.has("startblockid") ? {type: "startblockid"} : startblockid), (lexer.has("startblockspace") ? {type: "startblockspace"} : startblockspace), (lexer.has("startblockstring") ? {type: "startblockstring"} : startblockstring), (lexer.has("startblockend") ? {type: "startblockend"} : startblockend), "CLAUSE_TEMPLATE", (lexer.has("markupendblock") ? {type: "markupendblock"} : markupendblock), (lexer.has("endjoinid") ? {type: "endjoinid"} : endjoinid), (lexer.has("endblockend") ? {type: "endblockend"} : endblockend)], "postprocess":  (data,l,reject) => {
            // Check that opening and closing clause tags match
            // Note: this line makes the parser non-context-free
                return {
                    type: 'JoinBinding',
                    template: data[6],
                    separator: JSON.parse(data[4].value),
                    fieldName: data[2]
                }
        }
        },
    {"name": "IF_BLOCK_INLINE", "symbols": [(lexer.has("startifid") ? {type: "startifid"} : startifid), (lexer.has("startblockspace") ? {type: "startblockspace"} : startblockspace), (lexer.has("startblockid") ? {type: "startblockid"} : startblockid), (lexer.has("startblockend") ? {type: "startblockend"} : startblockend), (lexer.has("Chunk") ? {type: "Chunk"} : Chunk), (lexer.has("markupendblock") ? {type: "markupendblock"} : markupendblock), (lexer.has("endifid") ? {type: "endifid"} : endifid), (lexer.has("endblockend") ? {type: "endblockend"} : endblockend)], "postprocess":  (data,l,reject) => {
            // Check that opening and closing clause tags match
            // Note: this line makes the parser non-context-free
                return {
                    type: 'IfBinding',
                    stringIf: data[4],
                    fieldName: data[2]
                }
        }
        },
    {"name": "IF_BLOCK_INLINE", "symbols": [(lexer.has("startifid") ? {type: "startifid"} : startifid), (lexer.has("startblockspace") ? {type: "startblockspace"} : startblockspace), (lexer.has("startblockid") ? {type: "startblockid"} : startblockid), (lexer.has("startblockend") ? {type: "startblockend"} : startblockend), (lexer.has("Chunk") ? {type: "Chunk"} : Chunk), (lexer.has("varelseid") ? {type: "varelseid"} : varelseid), (lexer.has("varend") ? {type: "varend"} : varend), (lexer.has("Chunk") ? {type: "Chunk"} : Chunk), (lexer.has("markupendblock") ? {type: "markupendblock"} : markupendblock), (lexer.has("endifid") ? {type: "endifid"} : endifid), (lexer.has("endblockend") ? {type: "endblockend"} : endblockend)], "postprocess":  (data,l,reject) => {
            // Check that opening and closing clause tags match
            // Note: this line makes the parser non-context-free
                return {
                    type: 'IfElseBinding',
                    stringIf: data[4],
                    stringElse: data[7],
                    fieldName: data[2]
                }
        }
        },
    {"name": "VARIABLE", "symbols": ["FORMATTED_BINDING"], "postprocess": id},
    {"name": "VARIABLE", "symbols": ["BINDING"], "postprocess": id},
    {"name": "FORMATTED_BINDING", "symbols": [(lexer.has("varid") ? {type: "varid"} : varid), (lexer.has("varspace") ? {type: "varspace"} : varspace), (lexer.has("varas") ? {type: "varas"} : varas), (lexer.has("varspace") ? {type: "varspace"} : varspace), (lexer.has("varstring") ? {type: "varstring"} : varstring), (lexer.has("varend") ? {type: "varend"} : varend)], "postprocess":  (data) => {
            return {
                type: 'FormattedBinding',
                fieldName: data[0],
                format: data[4],
            };
        }
        },
    {"name": "BINDING", "symbols": [(lexer.has("varid") ? {type: "varid"} : varid), (lexer.has("varend") ? {type: "varend"} : varend)], "postprocess":  (data) => {
            return {
                type: 'Binding',
                fieldName: data[0]
            };
        }
        }
]
  , ParserStart: "TEMPLATE"
}
if (typeof module !== 'undefined'&& typeof module.exports !== 'undefined') {
   module.exports = grammar;
} else {
   window.grammar = grammar;
}
})();
